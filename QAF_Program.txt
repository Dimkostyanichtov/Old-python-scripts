program
	 Adaptive_rejection_part;

{rejection of periodic noise}
	uses
		Crt, math;

const   m=0.0008; {константа, задающая скорость адаптации фильтра}
        n_step=2000; {длина массива коэффициентов b}
        f_discr=1.0e+6; {частота дискретизации исходного файла сигнала}
        t_step=1/f_discr; {шаг дискретизации по времени}
        f_noise1=50.0;    {частота 1й гармоники помехи- их может быть сколько угодно}
        f_noise2=100.0;   {частота 2й гармоники помехи}
        f_noise3=150.0;   {частота 3й гармоники помехи}
        two_pi=2*pi;      {посчитали, чему равно два пи}
        rpt=1;            {число повторов процедуры фильтрации исходного файла}


var
x, n, b			     :array [1..n_step] of real;
t                            :real;
s_data, s, c, y              :real;
i, j, k, cycle               :Integer;


data_file, source_file       :text;


Begin
{инициализируем файл исходных данных с записью сигнала и открываем на запись
файл с данными фильтрованного сигнала}
        assign (source_file, 'e:\science\adaptive\source.txt');
        assign (data_file, 'e:\science\adaptive\data.txt');
        rewrite (data_file);
        reset (source_file);
{синтезируем сигнал помехи, который будем вычитать. он будет содержать
три гармоники частоты 50 Гц. записываем его в массив n}
        t:=0.0;
	for i:=1 to n_step do
                begin
                        n[i]:=cos(two_pi*f_noise1*t)
                        +sin(two_pi*f_noise2*t)+sin(two_pi*f_noise3*t);
                        t:=t+t_step;
                end;

{инициализируем рабочий массив весовых коэффициентов b и рабочий массив для помехи x}
        for i:=1 to n_step do b[i]:=0.0;
	for i:=1 to n_step do x[i]:=0.0;

        for cycle:=1 to rpt do begin {начало самого внешнего цикла по числу повторов процедуры фильтрации}
        rewrite (data_file);
        reset (source_file);


	i:=1; j:=1; k:=1; t:=0.0;

        while Not Eof(source_file)  do
	begin
	        s:=0;
                y:=0;

                for k:= n_step downto 2 do x[k]:=x[k-1]; {сдвиг сигнала помехи по рабочему массиву}

                x[1]:=n[j]; {загрузка сигнала помехи в рабочий массив}


                readln(source_file, s_data);   {читаем отсчёт исходного сигнала}


	        for k:= 1 to n_step do y:=y+x[k]*b[k];  {вычисляем сумму по всем весовым коэффициентам
                для сигнала помехи}

                if y>1.0 then y:=1.0;
                if y<-1.0 then y:=-1.0;    {защита от неустойчивости - может возникнуть при больших m}

                s:=s_data-y;      {вычитаем вычисленный отсчёт сигнала помехи из исходного сигнала}

                if s>1.0 then s:=1.0;
                if s<-1.0 then s:=-1.0;    {защита от неустойчивости}

                writeln(data_file, t,' ', s); {записываем результат - время и отсчёт - в выходной файл}

                t:=t+t_step; {вычисляем время, соответствующее текущему отсчёту исходного сигнала}

                {вычисляем новые значения весовых коэффициентов b}
                c:=2*m*s;
                for k:= 1 to n_step do b[k]:=b[k]+x[k]*c;
                i:=i+1;
                if j=n_step then j:=1 else j:=j+1;
	end; {конец цикла по обработке отсчётов исходного сигнала}
        end; {конец самого внешнего цикла по числу проходов фильтра}

        {закрываем обращения к исходному и выходному файлам данных}
        Close(source_file);
        Close(data_file);
End.
